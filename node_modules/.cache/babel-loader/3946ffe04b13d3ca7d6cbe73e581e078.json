{"ast":null,"code":"var _jsxFileName = \"/Users/aawferris/Local_Repos/BlackwaterChat/src/components/Tile/Tile.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useMemo, useRef } from 'react';\nimport './Tile.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n\n      return `${kind} blocked`;\n\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n\n      return `${kind} off`;\n\n    case 'sendable':\n      return `${kind} not subscribed`;\n\n    case 'loading':\n      return `${kind} loading...`;\n\n    case 'interrupted':\n      return `${kind} interrupted`;\n\n    case 'playable':\n      return null;\n  }\n}\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n */\n\n\nexport default function Tile(props) {\n  _s();\n\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n  const videoTrack = useMemo(() => {\n    var _props$videoTrackStat;\n\n    // For video let's use the `track` field, which is only present when video\n    // is in the \"playable\" state.\n    // (Using `persistentTrack` could result in a still frame being shown when\n    // remote video is muted).\n    return (_props$videoTrackStat = props.videoTrackState) === null || _props$videoTrackStat === void 0 ? void 0 : _props$videoTrackStat.track;\n  }, [props.videoTrackState]);\n  const audioTrack = useMemo(() => {\n    var _props$audioTrackStat;\n\n    // For audio let's use the `persistentTrack` field, which is present whether\n    // or not audio is in the \"playable\" state.\n    // (Using `track` would result in a bug where, if remote audio were unmuted\n    // while this call was is in a Safari background tab, audio wouldn't resume\n    // playing).\n    return (_props$audioTrackStat = props.audioTrackState) === null || _props$audioTrackStat === void 0 ? void 0 : _props$audioTrackStat.persistentTrack;\n  }, [props.audioTrackState]);\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n  /**\n   * When video track changes, update video srcObject\n   */\n\n  useEffect(() => {\n    videoEl.current && (videoEl.current.srcObject = videoTrack && new MediaStream([videoTrack]));\n  }, [videoTrack]);\n  /**\n   * When audio track changes, update audio srcObject\n   */\n\n  useEffect(() => {\n    audioEl.current && (audioEl.current.srcObject = audioTrack && new MediaStream([audioTrack]));\n  }, [audioTrack]);\n\n  function getVideoComponent() {\n    return videoTrack && /*#__PURE__*/_jsxDEV(\"video\", {\n      autoPlay: true,\n      muted: true,\n      playsInline: true,\n      ref: videoEl\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 26\n    }, this);\n  }\n\n  function getAudioComponent() {\n    return !props.isLocalPerson && audioTrack && /*#__PURE__*/_jsxDEV(\"audio\", {\n      autoPlay: true,\n      playsInline: true,\n      ref: audioEl\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 21\n    }, this);\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return videoUnavailableMessage && /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"overlay\",\n      children: [videoUnavailableMessage, audioUnavailableMessage && /*#__PURE__*/_jsxDEV(_Fragment, {\n        children: [/*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 105,\n          columnNumber: 15\n        }, this), audioUnavailableMessage]\n      }, void 0, true)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 9\n    }, this);\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return !props.disableCornerMessage && audioUnavailableMessage && !videoUnavailableMessage && /*#__PURE__*/_jsxDEV(\"p\", {\n      className: \"corner\",\n      children: audioUnavailableMessage\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 9\n    }, this);\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    return classNames;\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: getClassNames(),\n    onClick: props.onClick,\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"background\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 7\n    }, this), getOverlayComponent(), getVideoComponent(), getAudioComponent(), getCornerMessageComponent()]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 133,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Tile, \"BWXtmh57sLro9mqBoT/WlAAjhbQ=\");\n\n_c = Tile;\n\nvar _c;\n\n$RefreshReg$(_c, \"Tile\");","map":{"version":3,"sources":["/Users/aawferris/Local_Repos/BlackwaterChat/src/components/Tile/Tile.js"],"names":["React","useEffect","useMemo","useRef","getTrackUnavailableMessage","kind","trackState","state","blocked","byPermissions","byDeviceMissing","off","byUser","byBandwidth","Tile","props","videoEl","audioEl","videoTrack","videoTrackState","track","audioTrack","audioTrackState","persistentTrack","videoUnavailableMessage","audioUnavailableMessage","current","srcObject","MediaStream","getVideoComponent","getAudioComponent","isLocalPerson","getOverlayComponent","getCornerMessageComponent","disableCornerMessage","getClassNames","classNames","isLarge","onClick"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef } from 'react';\nimport './Tile.css';\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n      return `${kind} blocked`;\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n      return `${kind} off`;\n    case 'sendable':\n      return `${kind} not subscribed`;\n    case 'loading':\n      return `${kind} loading...`;\n    case 'interrupted':\n      return `${kind} interrupted`;\n    case 'playable':\n      return null;\n  }\n}\n\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n */\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n\n  const videoTrack = useMemo(() => {\n    // For video let's use the `track` field, which is only present when video\n    // is in the \"playable\" state.\n    // (Using `persistentTrack` could result in a still frame being shown when\n    // remote video is muted).\n    return props.videoTrackState?.track;\n  }, [props.videoTrackState]);\n\n  const audioTrack = useMemo(() => {\n    // For audio let's use the `persistentTrack` field, which is present whether\n    // or not audio is in the \"playable\" state.\n    // (Using `track` would result in a bug where, if remote audio were unmuted\n    // while this call was is in a Safari background tab, audio wouldn't resume\n    // playing).\n    return props.audioTrackState?.persistentTrack;\n  }, [props.audioTrackState]);\n\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n\n  /**\n   * When video track changes, update video srcObject\n   */\n  useEffect(() => {\n    videoEl.current &&\n      (videoEl.current.srcObject = videoTrack && new MediaStream([videoTrack]));\n  }, [videoTrack]);\n\n  /**\n   * When audio track changes, update audio srcObject\n   */\n  useEffect(() => {\n    audioEl.current &&\n      (audioEl.current.srcObject = audioTrack && new MediaStream([audioTrack]));\n  }, [audioTrack]);\n\n  function getVideoComponent() {\n    return videoTrack && <video autoPlay muted playsInline ref={videoEl} />;\n  }\n\n  function getAudioComponent() {\n    return (\n      !props.isLocalPerson &&\n      audioTrack && <audio autoPlay playsInline ref={audioEl} />\n    );\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return (\n      videoUnavailableMessage && (\n        <p className=\"overlay\">\n          {videoUnavailableMessage}\n          {audioUnavailableMessage && (\n            <>\n              <br />\n              {audioUnavailableMessage}\n            </>\n          )}\n        </p>\n      )\n    );\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return (\n      !props.disableCornerMessage &&\n      audioUnavailableMessage &&\n      !videoUnavailableMessage && (\n        <p className=\"corner\">{audioUnavailableMessage}</p>\n      )\n    );\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    return classNames;\n  }\n\n  return (\n    <div className={getClassNames()} onClick={props.onClick}>\n      <div className=\"background\" />\n      {getOverlayComponent()}\n      {getVideoComponent()}\n      {getAudioComponent()}\n      {getCornerMessageComponent()}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}