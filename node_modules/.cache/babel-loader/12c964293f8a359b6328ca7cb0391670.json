{"ast":null,"code":"import React,{useEffect,useMemo,useRef}from'react';import'./Tile.css';import{jsx as _jsx}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";function getTrackUnavailableMessage(kind,trackState){if(!trackState)return;switch(trackState.state){case'blocked':if(trackState.blocked.byPermissions){return\"\".concat(kind,\" permission denied\");}else if(trackState.blocked.byDeviceMissing){return\"\".concat(kind,\" device missing\");}return\"\".concat(kind,\" blocked\");case'off':if(trackState.off.byUser){return\"\".concat(kind,\" muted\");}else if(trackState.off.byBandwidth){return\"\".concat(kind,\" muted to save bandwidth\");}return\"\".concat(kind,\" off\");case'sendable':return\"\".concat(kind,\" not subscribed\");case'loading':return\"\".concat(kind,\" loading...\");case'interrupted':return\"\".concat(kind,\" interrupted\");case'playable':return null;}}/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n */export default function Tile(props){var videoEl=useRef(null);var audioEl=useRef(null);var videoTrack=useMemo(function(){var _props$videoTrackStat;// For video let's use the `track` field, which is only present when video\n// is in the \"playable\" state.\n// (Using `persistentTrack` could result in a still frame being shown when\n// remote video is muted).\nreturn(_props$videoTrackStat=props.videoTrackState)===null||_props$videoTrackStat===void 0?void 0:_props$videoTrackStat.track;},[props.videoTrackState]);var audioTrack=useMemo(function(){var _props$audioTrackStat;// For audio let's use the `persistentTrack` field, which is present whether\n// or not audio is in the \"playable\" state.\n// (Using `track` would result in a bug where, if remote audio were unmuted\n// while this call was is in a Safari background tab, audio wouldn't resume\n// playing).\nreturn(_props$audioTrackStat=props.audioTrackState)===null||_props$audioTrackStat===void 0?void 0:_props$audioTrackStat.persistentTrack;},[props.audioTrackState]);var videoUnavailableMessage=useMemo(function(){return getTrackUnavailableMessage('video',props.videoTrackState);},[props.videoTrackState]);var audioUnavailableMessage=useMemo(function(){return getTrackUnavailableMessage('audio',props.audioTrackState);},[props.audioTrackState]);/**\n   * When video track changes, update video srcObject\n   */useEffect(function(){videoEl.current&&(videoEl.current.srcObject=videoTrack&&new MediaStream([videoTrack]));},[videoTrack]);/**\n   * When audio track changes, update audio srcObject\n   */useEffect(function(){audioEl.current&&(audioEl.current.srcObject=audioTrack&&new MediaStream([audioTrack]));},[audioTrack]);function getVideoComponent(){return videoTrack&&/*#__PURE__*/_jsx(\"video\",{autoPlay:true,muted:true,playsInline:true,ref:videoEl});}function getAudioComponent(){return!props.isLocalPerson&&audioTrack&&/*#__PURE__*/_jsx(\"audio\",{autoPlay:true,playsInline:true,ref:audioEl});}function getOverlayComponent(){// Show overlay when video is unavailable. Audio may be unavailable too.\nreturn videoUnavailableMessage&&/*#__PURE__*/_jsxs(\"p\",{className:\"overlay\",children:[videoUnavailableMessage,audioUnavailableMessage&&/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(\"br\",{}),audioUnavailableMessage]})]});}function getCornerMessageComponent(){// Show corner message when only audio is unavailable.\nreturn!props.disableCornerMessage&&audioUnavailableMessage&&!videoUnavailableMessage&&/*#__PURE__*/_jsx(\"p\",{className:\"corner\",children:audioUnavailableMessage});}function getClassNames(){var classNames='tile';classNames+=props.isLarge?' large':' small';props.isLocalPerson&&(classNames+=' local');return classNames;}return/*#__PURE__*/_jsxs(\"div\",{className:getClassNames(),onClick:props.onClick,children:[/*#__PURE__*/_jsx(\"div\",{className:\"background\"}),getOverlayComponent(),getVideoComponent(),getAudioComponent(),getCornerMessageComponent()]});}","map":{"version":3,"sources":["/Users/aawferris/Local_Repos/BlackwaterChat/src/components/Tile/Tile.js"],"names":["React","useEffect","useMemo","useRef","getTrackUnavailableMessage","kind","trackState","state","blocked","byPermissions","byDeviceMissing","off","byUser","byBandwidth","Tile","props","videoEl","audioEl","videoTrack","videoTrackState","track","audioTrack","audioTrackState","persistentTrack","videoUnavailableMessage","audioUnavailableMessage","current","srcObject","MediaStream","getVideoComponent","getAudioComponent","isLocalPerson","getOverlayComponent","getCornerMessageComponent","disableCornerMessage","getClassNames","classNames","isLarge","onClick"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef } from 'react';\nimport './Tile.css';\n\nfunction getTrackUnavailableMessage(kind, trackState) {\n  if (!trackState) return;\n  switch (trackState.state) {\n    case 'blocked':\n      if (trackState.blocked.byPermissions) {\n        return `${kind} permission denied`;\n      } else if (trackState.blocked.byDeviceMissing) {\n        return `${kind} device missing`;\n      }\n      return `${kind} blocked`;\n    case 'off':\n      if (trackState.off.byUser) {\n        return `${kind} muted`;\n      } else if (trackState.off.byBandwidth) {\n        return `${kind} muted to save bandwidth`;\n      }\n      return `${kind} off`;\n    case 'sendable':\n      return `${kind} not subscribed`;\n    case 'loading':\n      return `${kind} loading...`;\n    case 'interrupted':\n      return `${kind} interrupted`;\n    case 'playable':\n      return null;\n  }\n}\n\n/**\n * Props\n * - videoTrackState: DailyTrackState?\n * - audioTrackState: DailyTrackState?\n * - isLocalPerson: boolean\n * - isLarge: boolean\n * - disableCornerMessage: boolean\n * - onClick: Function\n */\nexport default function Tile(props) {\n  const videoEl = useRef(null);\n  const audioEl = useRef(null);\n\n  const videoTrack = useMemo(() => {\n    // For video let's use the `track` field, which is only present when video\n    // is in the \"playable\" state.\n    // (Using `persistentTrack` could result in a still frame being shown when\n    // remote video is muted).\n    return props.videoTrackState?.track;\n  }, [props.videoTrackState]);\n\n  const audioTrack = useMemo(() => {\n    // For audio let's use the `persistentTrack` field, which is present whether\n    // or not audio is in the \"playable\" state.\n    // (Using `track` would result in a bug where, if remote audio were unmuted\n    // while this call was is in a Safari background tab, audio wouldn't resume\n    // playing).\n    return props.audioTrackState?.persistentTrack;\n  }, [props.audioTrackState]);\n\n  const videoUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('video', props.videoTrackState);\n  }, [props.videoTrackState]);\n\n  const audioUnavailableMessage = useMemo(() => {\n    return getTrackUnavailableMessage('audio', props.audioTrackState);\n  }, [props.audioTrackState]);\n\n  /**\n   * When video track changes, update video srcObject\n   */\n  useEffect(() => {\n    videoEl.current &&\n      (videoEl.current.srcObject = videoTrack && new MediaStream([videoTrack]));\n  }, [videoTrack]);\n\n  /**\n   * When audio track changes, update audio srcObject\n   */\n  useEffect(() => {\n    audioEl.current &&\n      (audioEl.current.srcObject = audioTrack && new MediaStream([audioTrack]));\n  }, [audioTrack]);\n\n  function getVideoComponent() {\n    return videoTrack && <video autoPlay muted playsInline ref={videoEl} />;\n  }\n\n  function getAudioComponent() {\n    return (\n      !props.isLocalPerson &&\n      audioTrack && <audio autoPlay playsInline ref={audioEl} />\n    );\n  }\n\n  function getOverlayComponent() {\n    // Show overlay when video is unavailable. Audio may be unavailable too.\n    return (\n      videoUnavailableMessage && (\n        <p className=\"overlay\">\n          {videoUnavailableMessage}\n          {audioUnavailableMessage && (\n            <>\n              <br />\n              {audioUnavailableMessage}\n            </>\n          )}\n        </p>\n      )\n    );\n  }\n\n  function getCornerMessageComponent() {\n    // Show corner message when only audio is unavailable.\n    return (\n      !props.disableCornerMessage &&\n      audioUnavailableMessage &&\n      !videoUnavailableMessage && (\n        <p className=\"corner\">{audioUnavailableMessage}</p>\n      )\n    );\n  }\n\n  function getClassNames() {\n    let classNames = 'tile';\n    classNames += props.isLarge ? ' large' : ' small';\n    props.isLocalPerson && (classNames += ' local');\n    return classNames;\n  }\n\n  return (\n    <div className={getClassNames()} onClick={props.onClick}>\n      <div className=\"background\" />\n      {getOverlayComponent()}\n      {getVideoComponent()}\n      {getAudioComponent()}\n      {getCornerMessageComponent()}\n    </div>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}